{"posts":[{"title":"My new Post ContenT","text":"我今天感到胃部有点难受，由于一些家庭琐事使我感到不快.","link":"/2020/10/29/My-new-Post-ContenT/"},{"title":"What","text":"just sad sad sad….","link":"/2020/10/28/What/"},{"title":"Your Project Title","text":"12import warningswarnings.filterwarnings('ignore') 123456789101112import numpy as npimport pandas as pd# The error metric: RMSE on the log of the sale prices.from sklearn.metrics import mean_squared_errordef rmse(y_true, y_pred): return np.sqrt(mean_squared_error(y_true, y_pred))# Load the data.train_df = pd.read_csv(&quot;/kaggle/input/house-price/train.csv&quot;)test_df = pd.read_csv(&quot;/kaggle/input/house-price/test.csv&quot;) 12345678910111213141516171819# There are a few houses with more than 4000 sq ft living area that are# outliers, so we drop them from the training data. (There is also one in# the test set but we obviously can't drop that one.)train_df.drop(train_df[train_df[&quot;GrLivArea&quot;] &gt; 4000].index, inplace=True)# The test example with ID 666 has GarageArea, GarageCars, and GarageType # but none of the other fields, so use the mode and median to fill them in.test_df.loc[666, &quot;GarageQual&quot;] = &quot;TA&quot;test_df.loc[666, &quot;GarageCond&quot;] = &quot;TA&quot;test_df.loc[666, &quot;GarageFinish&quot;] = &quot;Unf&quot;test_df.loc[666, &quot;GarageYrBlt&quot;] = &quot;1980&quot;# The test example 1116 only has GarageType but no other information. We'll # assume it does not have a garage.test_df.loc[1116, &quot;GarageType&quot;] = np.nan# For imputing missing values: fill in missing LotFrontage values by the median# LotFrontage of the neighborhood.lot_frontage_by_neighborhood = train_df[&quot;LotFrontage&quot;].groupby(train_df[&quot;Neighborhood&quot;]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288# Used to convert categorical features into ordinal numbers.# (There's probably an easier way to do this, but it works.)from sklearn.preprocessing import LabelEncoderle = LabelEncoder()def factorize(df, factor_df, column, fill_na=None): factor_df[column] = df[column] if fill_na is not None: factor_df[column].fillna(fill_na, inplace=True) le.fit(factor_df[column].unique()) factor_df[column] = le.transform(factor_df[column]) return factor_df# Combine all the (numerical) features into one big DataFrame. We don't add # the one-hot encoded variables here yet, that happens later on.def munge(df): all_df = pd.DataFrame(index = df.index) all_df[&quot;LotFrontage&quot;] = df[&quot;LotFrontage&quot;] for key, group in lot_frontage_by_neighborhood: idx = (df[&quot;Neighborhood&quot;] == key) &amp; (df[&quot;LotFrontage&quot;].isnull()) all_df.loc[idx, &quot;LotFrontage&quot;] = group.median() all_df[&quot;LotArea&quot;] = df[&quot;LotArea&quot;] all_df[&quot;MasVnrArea&quot;] = df[&quot;MasVnrArea&quot;] all_df[&quot;MasVnrArea&quot;].fillna(0, inplace=True) all_df[&quot;BsmtFinSF1&quot;] = df[&quot;BsmtFinSF1&quot;] all_df[&quot;BsmtFinSF1&quot;].fillna(0, inplace=True) all_df[&quot;BsmtFinSF2&quot;] = df[&quot;BsmtFinSF2&quot;] all_df[&quot;BsmtFinSF2&quot;].fillna(0, inplace=True) all_df[&quot;BsmtUnfSF&quot;] = df[&quot;BsmtUnfSF&quot;] all_df[&quot;BsmtUnfSF&quot;].fillna(0, inplace=True) all_df[&quot;TotalBsmtSF&quot;] = df[&quot;TotalBsmtSF&quot;] all_df[&quot;TotalBsmtSF&quot;].fillna(0, inplace=True) all_df[&quot;1stFlrSF&quot;] = df[&quot;1stFlrSF&quot;] all_df[&quot;2ndFlrSF&quot;] = df[&quot;2ndFlrSF&quot;] all_df[&quot;GrLivArea&quot;] = df[&quot;GrLivArea&quot;] all_df[&quot;GarageArea&quot;] = df[&quot;GarageArea&quot;] all_df[&quot;GarageArea&quot;].fillna(0, inplace=True) all_df[&quot;WoodDeckSF&quot;] = df[&quot;WoodDeckSF&quot;] all_df[&quot;OpenPorchSF&quot;] = df[&quot;OpenPorchSF&quot;] all_df[&quot;EnclosedPorch&quot;] = df[&quot;EnclosedPorch&quot;] all_df[&quot;3SsnPorch&quot;] = df[&quot;3SsnPorch&quot;] all_df[&quot;ScreenPorch&quot;] = df[&quot;ScreenPorch&quot;] all_df[&quot;BsmtFullBath&quot;] = df[&quot;BsmtFullBath&quot;] all_df[&quot;BsmtFullBath&quot;].fillna(0, inplace=True) all_df[&quot;BsmtHalfBath&quot;] = df[&quot;BsmtHalfBath&quot;] all_df[&quot;BsmtHalfBath&quot;].fillna(0, inplace=True) all_df[&quot;FullBath&quot;] = df[&quot;FullBath&quot;] all_df[&quot;HalfBath&quot;] = df[&quot;HalfBath&quot;] all_df[&quot;BedroomAbvGr&quot;] = df[&quot;BedroomAbvGr&quot;] all_df[&quot;KitchenAbvGr&quot;] = df[&quot;KitchenAbvGr&quot;] all_df[&quot;TotRmsAbvGrd&quot;] = df[&quot;TotRmsAbvGrd&quot;] all_df[&quot;Fireplaces&quot;] = df[&quot;Fireplaces&quot;] all_df[&quot;GarageCars&quot;] = df[&quot;GarageCars&quot;] all_df[&quot;GarageCars&quot;].fillna(0, inplace=True) all_df[&quot;CentralAir&quot;] = (df[&quot;CentralAir&quot;] == &quot;Y&quot;) * 1.0 all_df[&quot;OverallQual&quot;] = df[&quot;OverallQual&quot;] all_df[&quot;OverallCond&quot;] = df[&quot;OverallCond&quot;] # Quality measurements are stored as text but we can convert them to # numbers where a higher number means higher quality. qual_dict = {np.nan: 0, &quot;Po&quot;: 1, &quot;Fa&quot;: 2, &quot;TA&quot;: 3, &quot;Gd&quot;: 4, &quot;Ex&quot;: 5} all_df[&quot;ExterQual&quot;] = df[&quot;ExterQual&quot;].map(qual_dict).astype(int) all_df[&quot;ExterCond&quot;] = df[&quot;ExterCond&quot;].map(qual_dict).astype(int) all_df[&quot;BsmtQual&quot;] = df[&quot;BsmtQual&quot;].map(qual_dict).astype(int)# all_df[&quot;BsmtCond&quot;] = df[&quot;BsmtCond&quot;].map(qual_dict).astype(int)# all_df[&quot;HeatingQC&quot;] = df[&quot;HeatingQC&quot;].map(qual_dict).astype(int) all_df[&quot;KitchenQual&quot;] = df[&quot;KitchenQual&quot;].map(qual_dict).astype(int) all_df[&quot;FireplaceQu&quot;] = df[&quot;FireplaceQu&quot;].map(qual_dict).astype(int)# all_df[&quot;GarageQual&quot;] = df[&quot;GarageQual&quot;].map(qual_dict).astype(int)# all_df[&quot;GarageCond&quot;] = df[&quot;GarageCond&quot;].map(qual_dict).astype(int)# all_df[&quot;BsmtExposure&quot;] = df[&quot;BsmtExposure&quot;].map( {np.nan: 0, &quot;No&quot;: 1, &quot;Mn&quot;: 2, &quot;Av&quot;: 3, &quot;Gd&quot;: 4}).astype(int) bsmt_fin_dict = {np.nan: 0, &quot;Unf&quot;: 1, &quot;LwQ&quot;: 2, &quot;Rec&quot;: 3, &quot;BLQ&quot;: 4, &quot;ALQ&quot;: 5, &quot;GLQ&quot;: 6} all_df[&quot;BsmtFinType1&quot;] = df[&quot;BsmtFinType1&quot;].map(bsmt_fin_dict).astype(int) all_df[&quot;BsmtFinType2&quot;] = df[&quot;BsmtFinType2&quot;].map(bsmt_fin_dict).astype(int) all_df[&quot;Functional&quot;] = df[&quot;Functional&quot;].map( {np.nan: 0, &quot;Sal&quot;: 1, &quot;Sev&quot;: 2, &quot;Maj2&quot;: 3, &quot;Maj1&quot;: 4, &quot;Mod&quot;: 5, &quot;Min2&quot;: 6, &quot;Min1&quot;: 7, &quot;Typ&quot;: 8}).astype(int) all_df[&quot;GarageFinish&quot;] = df[&quot;GarageFinish&quot;].map( {np.nan: 0, &quot;Unf&quot;: 1, &quot;RFn&quot;: 2, &quot;Fin&quot;: 3}).astype(int) all_df[&quot;Fence&quot;] = df[&quot;Fence&quot;].map( {np.nan: 0, &quot;MnWw&quot;: 1, &quot;GdWo&quot;: 2, &quot;MnPrv&quot;: 3, &quot;GdPrv&quot;: 4}).astype(int) all_df[&quot;YearBuilt&quot;] = df[&quot;YearBuilt&quot;] all_df[&quot;YearRemodAdd&quot;] = df[&quot;YearRemodAdd&quot;] all_df[&quot;GarageYrBlt&quot;] = df[&quot;GarageYrBlt&quot;] all_df[&quot;GarageYrBlt&quot;].fillna(0.0, inplace=True) all_df[&quot;MoSold&quot;] = df[&quot;MoSold&quot;] all_df[&quot;YrSold&quot;] = df[&quot;YrSold&quot;] all_df[&quot;LowQualFinSF&quot;] = df[&quot;LowQualFinSF&quot;] all_df[&quot;MiscVal&quot;] = df[&quot;MiscVal&quot;] # df[&quot;PoolQC&quot;].fillna(&quot;NA&quot;, inplace=True) # all_df[&quot;PoolQC&quot;] = df[&quot;PoolQC&quot;].map(qual_dict).astype(int)# all_df[&quot;PoolArea&quot;] = df[&quot;PoolArea&quot;] all_df[&quot;PoolArea&quot;].fillna(0, inplace=True) # Add categorical features as numbers too. It seems to help a bit. all_df = factorize(df, all_df, &quot;MSSubClass&quot;) all_df = factorize(df, all_df, &quot;MSZoning&quot;, &quot;RL&quot;) all_df = factorize(df, all_df, &quot;LotConfig&quot;) all_df = factorize(df, all_df, &quot;Neighborhood&quot;) all_df = factorize(df, all_df, &quot;Condition1&quot;) all_df = factorize(df, all_df, &quot;BldgType&quot;) all_df = factorize(df, all_df, &quot;HouseStyle&quot;) all_df = factorize(df, all_df, &quot;RoofStyle&quot;) all_df = factorize(df, all_df, &quot;Exterior1st&quot;, &quot;Other&quot;) all_df = factorize(df, all_df, &quot;Exterior2nd&quot;, &quot;Other&quot;) all_df = factorize(df, all_df, &quot;MasVnrType&quot;, &quot;None&quot;) all_df = factorize(df, all_df, &quot;Foundation&quot;) all_df = factorize(df, all_df, &quot;SaleType&quot;, &quot;Oth&quot;) all_df = factorize(df, all_df, &quot;SaleCondition&quot;) # IR2 and IR3 don't appear that often, so just make a distinction # between regular and irregular. all_df[&quot;IsRegularLotShape&quot;] = (df[&quot;LotShape&quot;] == &quot;Reg&quot;) * 1 # Most properties are level; bin the other possibilities together # as &quot;not level&quot;. all_df[&quot;IsLandLevel&quot;] = (df[&quot;LandContour&quot;] == &quot;Lvl&quot;) * 1 # Most land slopes are gentle; treat the others as &quot;not gentle&quot;. all_df[&quot;IsLandSlopeGentle&quot;] = (df[&quot;LandSlope&quot;] == &quot;Gtl&quot;) * 1 # Most properties use standard circuit breakers. all_df[&quot;IsElectricalSBrkr&quot;] = (df[&quot;Electrical&quot;] == &quot;SBrkr&quot;) * 1 # About 2/3rd have an attached garage. all_df[&quot;IsGarageDetached&quot;] = (df[&quot;GarageType&quot;] == &quot;Detchd&quot;) * 1 # Most have a paved drive. Treat dirt/gravel and partial pavement # as &quot;not paved&quot;. all_df[&quot;IsPavedDrive&quot;] = (df[&quot;PavedDrive&quot;] == &quot;Y&quot;) * 1 # The only interesting &quot;misc. feature&quot; is the presence of a shed. all_df[&quot;HasShed&quot;] = (df[&quot;MiscFeature&quot;] == &quot;Shed&quot;) * 1. # If YearRemodAdd != YearBuilt, then a remodeling took place at some point. all_df[&quot;Remodeled&quot;] = (all_df[&quot;YearRemodAdd&quot;] != all_df[&quot;YearBuilt&quot;]) * 1 # Did a remodeling happen in the year the house was sold? all_df[&quot;RecentRemodel&quot;] = (all_df[&quot;YearRemodAdd&quot;] == all_df[&quot;YrSold&quot;]) * 1 # Was this house sold in the year it was built? all_df[&quot;VeryNewHouse&quot;] = (all_df[&quot;YearBuilt&quot;] == all_df[&quot;YrSold&quot;]) * 1 all_df[&quot;Has2ndFloor&quot;] = (all_df[&quot;2ndFlrSF&quot;] == 0) * 1 all_df[&quot;HasMasVnr&quot;] = (all_df[&quot;MasVnrArea&quot;] == 0) * 1 all_df[&quot;HasWoodDeck&quot;] = (all_df[&quot;WoodDeckSF&quot;] == 0) * 1 all_df[&quot;HasOpenPorch&quot;] = (all_df[&quot;OpenPorchSF&quot;] == 0) * 1 all_df[&quot;HasEnclosedPorch&quot;] = (all_df[&quot;EnclosedPorch&quot;] == 0) * 1 all_df[&quot;Has3SsnPorch&quot;] = (all_df[&quot;3SsnPorch&quot;] == 0) * 1 all_df[&quot;HasScreenPorch&quot;] = (all_df[&quot;ScreenPorch&quot;] == 0) * 1 # Months with the largest number of deals may be significant. all_df[&quot;HighSeason&quot;] = df[&quot;MoSold&quot;].replace( {1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0}) all_df[&quot;NewerDwelling&quot;] = df[&quot;MSSubClass&quot;].replace( {20: 1, 30: 0, 40: 0, 45: 0,50: 0, 60: 1, 70: 0, 75: 0, 80: 0, 85: 0, 90: 0, 120: 1, 150: 0, 160: 0, 180: 0, 190: 0}) all_df.loc[df.Neighborhood == 'NridgHt', &quot;Neighborhood_Good&quot;] = 1 all_df.loc[df.Neighborhood == 'Crawfor', &quot;Neighborhood_Good&quot;] = 1 all_df.loc[df.Neighborhood == 'StoneBr', &quot;Neighborhood_Good&quot;] = 1 all_df.loc[df.Neighborhood == 'Somerst', &quot;Neighborhood_Good&quot;] = 1 all_df.loc[df.Neighborhood == 'NoRidge', &quot;Neighborhood_Good&quot;] = 1 all_df[&quot;Neighborhood_Good&quot;].fillna(0, inplace=True) all_df[&quot;SaleCondition_PriceDown&quot;] = df.SaleCondition.replace( {'Abnorml': 1, 'Alloca': 1, 'AdjLand': 1, 'Family': 1, 'Normal': 0, 'Partial': 0}) # House completed before sale or not all_df[&quot;BoughtOffPlan&quot;] = df.SaleCondition.replace( {&quot;Abnorml&quot; : 0, &quot;Alloca&quot; : 0, &quot;AdjLand&quot; : 0, &quot;Family&quot; : 0, &quot;Normal&quot; : 0, &quot;Partial&quot; : 1}) all_df[&quot;BadHeating&quot;] = df.HeatingQC.replace( {'Ex': 0, 'Gd': 0, 'TA': 0, 'Fa': 1, 'Po': 1}) area_cols = ['LotFrontage', 'LotArea', 'MasVnrArea', 'BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF', 'TotalBsmtSF', '1stFlrSF', '2ndFlrSF', 'GrLivArea', 'GarageArea', 'WoodDeckSF', 'OpenPorchSF', 'EnclosedPorch', '3SsnPorch', 'ScreenPorch', 'LowQualFinSF', 'PoolArea' ] all_df[&quot;TotalArea&quot;] = all_df[area_cols].sum(axis=1) all_df[&quot;TotalArea1st2nd&quot;] = all_df[&quot;1stFlrSF&quot;] + all_df[&quot;2ndFlrSF&quot;] all_df[&quot;Age&quot;] = 2010 - all_df[&quot;YearBuilt&quot;] all_df[&quot;TimeSinceSold&quot;] = 2010 - all_df[&quot;YrSold&quot;] all_df[&quot;SeasonSold&quot;] = all_df[&quot;MoSold&quot;].map({12:0, 1:0, 2:0, 3:1, 4:1, 5:1, 6:2, 7:2, 8:2, 9:3, 10:3, 11:3}).astype(int) all_df[&quot;YearsSinceRemodel&quot;] = all_df[&quot;YrSold&quot;] - all_df[&quot;YearRemodAdd&quot;] # Simplifications of existing features into bad/average/good. all_df[&quot;SimplOverallQual&quot;] = all_df.OverallQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2, 6 : 2, 7 : 3, 8 : 3, 9 : 3, 10 : 3}) all_df[&quot;SimplOverallCond&quot;] = all_df.OverallCond.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2, 6 : 2, 7 : 3, 8 : 3, 9 : 3, 10 : 3}) all_df[&quot;SimplPoolQC&quot;] = all_df.PoolQC.replace( {1 : 1, 2 : 1, 3 : 2, 4 : 2}) all_df[&quot;SimplGarageCond&quot;] = all_df.GarageCond.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplGarageQual&quot;] = all_df.GarageQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplFireplaceQu&quot;] = all_df.FireplaceQu.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplFireplaceQu&quot;] = all_df.FireplaceQu.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplFunctional&quot;] = all_df.Functional.replace( {1 : 1, 2 : 1, 3 : 2, 4 : 2, 5 : 3, 6 : 3, 7 : 3, 8 : 4}) all_df[&quot;SimplKitchenQual&quot;] = all_df.KitchenQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplHeatingQC&quot;] = all_df.HeatingQC.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplBsmtFinType1&quot;] = all_df.BsmtFinType1.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2, 6 : 2}) all_df[&quot;SimplBsmtFinType2&quot;] = all_df.BsmtFinType2.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2, 6 : 2}) all_df[&quot;SimplBsmtCond&quot;] = all_df.BsmtCond.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplBsmtQual&quot;] = all_df.BsmtQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplExterCond&quot;] = all_df.ExterCond.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplExterQual&quot;] = all_df.ExterQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) # Bin by neighborhood (a little arbitrarily). Values were computed by: # train_df[&quot;SalePrice&quot;].groupby(train_df[&quot;Neighborhood&quot;]).median().sort_values() neighborhood_map = { &quot;MeadowV&quot; : 0, # 88000 &quot;IDOTRR&quot; : 1, # 103000 &quot;BrDale&quot; : 1, # 106000 &quot;OldTown&quot; : 1, # 119000 &quot;Edwards&quot; : 1, # 119500 &quot;BrkSide&quot; : 1, # 124300 &quot;Sawyer&quot; : 1, # 135000 &quot;Blueste&quot; : 1, # 137500 &quot;SWISU&quot; : 2, # 139500 &quot;NAmes&quot; : 2, # 140000 &quot;NPkVill&quot; : 2, # 146000 &quot;Mitchel&quot; : 2, # 153500 &quot;SawyerW&quot; : 2, # 179900 &quot;Gilbert&quot; : 2, # 181000 &quot;NWAmes&quot; : 2, # 182900 &quot;Blmngtn&quot; : 2, # 191000 &quot;CollgCr&quot; : 2, # 197200 &quot;ClearCr&quot; : 3, # 200250 &quot;Crawfor&quot; : 3, # 200624 &quot;Veenker&quot; : 3, # 218000 &quot;Somerst&quot; : 3, # 225500 &quot;Timber&quot; : 3, # 228475 &quot;StoneBr&quot; : 4, # 278000 &quot;NoRidge&quot; : 4, # 290000 &quot;NridgHt&quot; : 4, # 315000 } all_df[&quot;NeighborhoodBin&quot;] = df[&quot;Neighborhood&quot;].map(neighborhood_map) return all_df 12345678910111213train_df_munged = munge(train_df)test_df_munged = munge(test_df)print(train_df_munged.shape)print(test_df_munged.shape)# Copy NeighborhoodBin into a temporary DataFrame because we want to use the# unscaled version later on (to one-hot encode it). neighborhood_bin_train = pd.DataFrame(index = train_df.index)neighborhood_bin_train[&quot;NeighborhoodBin&quot;] = train_df_munged[&quot;NeighborhoodBin&quot;]neighborhood_bin_test = pd.DataFrame(index = test_df.index)neighborhood_bin_test[&quot;NeighborhoodBin&quot;] = test_df_munged[&quot;NeighborhoodBin&quot;] (1456, 111) (1459, 111) 12345678910111213141516171819202122232425numeric_features = train_df_munged.dtypes[train_df_munged.dtypes != &quot;object&quot;].index# Transform the skewed numeric features by taking log(feature + 1).# This will make the features more normal.from scipy.stats import skewskewed = train_df_munged[numeric_features].apply(lambda x: skew(x.dropna().astype(float)))skewed = skewed[skewed &gt; 0.75]skewed = skewed.indextrain_df_munged[skewed] = np.log1p(train_df_munged[skewed])test_df_munged[skewed] = np.log1p(test_df_munged[skewed])# Additional processing: scale the data. from sklearn.preprocessing import StandardScalerscaler = StandardScaler()scaler.fit(train_df_munged[numeric_features])scaled = scaler.transform(train_df_munged[numeric_features])for i, col in enumerate(numeric_features): train_df_munged[col] = scaled[:, i]scaled = scaler.transform(test_df_munged[numeric_features])for i, col in enumerate(numeric_features): test_df_munged[col] = scaled[:, i] 123456789101112131415# Convert categorical features using one-hot encoding.def onehot(onehot_df, df, column_name, fill_na, drop_name): onehot_df[column_name] = df[column_name] if fill_na is not None: onehot_df[column_name].fillna(fill_na, inplace=True) dummies = pd.get_dummies(onehot_df[column_name], prefix=&quot;_&quot; + column_name) # Dropping one of the columns actually made the results slightly worse. # if drop_name is not None: # dummies.drop([&quot;_&quot; + column_name + &quot;_&quot; + drop_name], axis=1, inplace=True) onehot_df = onehot_df.join(dummies) onehot_df = onehot_df.drop([column_name], axis=1) return onehot_df 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576def munge_onehot(df): onehot_df = pd.DataFrame(index = df.index) onehot_df = onehot(onehot_df, df, &quot;MSSubClass&quot;, None, &quot;40&quot;) onehot_df = onehot(onehot_df, df, &quot;MSZoning&quot;, &quot;RL&quot;, &quot;RH&quot;) onehot_df = onehot(onehot_df, df, &quot;LotConfig&quot;, None, &quot;FR3&quot;) onehot_df = onehot(onehot_df, df, &quot;Neighborhood&quot;, None, &quot;OldTown&quot;) onehot_df = onehot(onehot_df, df, &quot;Condition1&quot;, None, &quot;RRNe&quot;) onehot_df = onehot(onehot_df, df, &quot;BldgType&quot;, None, &quot;2fmCon&quot;) onehot_df = onehot(onehot_df, df, &quot;HouseStyle&quot;, None, &quot;1.5Unf&quot;) onehot_df = onehot(onehot_df, df, &quot;RoofStyle&quot;, None, &quot;Shed&quot;) onehot_df = onehot(onehot_df, df, &quot;Exterior1st&quot;, &quot;VinylSd&quot;, &quot;CBlock&quot;) onehot_df = onehot(onehot_df, df, &quot;Exterior2nd&quot;, &quot;VinylSd&quot;, &quot;CBlock&quot;) onehot_df = onehot(onehot_df, df, &quot;Foundation&quot;, None, &quot;Wood&quot;) onehot_df = onehot(onehot_df, df, &quot;SaleType&quot;, &quot;WD&quot;, &quot;Oth&quot;) onehot_df = onehot(onehot_df, df, &quot;SaleCondition&quot;, &quot;Normal&quot;, &quot;AdjLand&quot;) # Fill in missing MasVnrType for rows that do have a MasVnrArea. temp_df = df[[&quot;MasVnrType&quot;, &quot;MasVnrArea&quot;]].copy() idx = (df[&quot;MasVnrArea&quot;] != 0) &amp; ((df[&quot;MasVnrType&quot;] == &quot;None&quot;) | (df[&quot;MasVnrType&quot;].isnull())) temp_df.loc[idx, &quot;MasVnrType&quot;] = &quot;BrkFace&quot; onehot_df = onehot(onehot_df, temp_df, &quot;MasVnrType&quot;, &quot;None&quot;, &quot;BrkCmn&quot;) # Also add the booleans from calc_df as dummy variables. onehot_df = onehot(onehot_df, df, &quot;LotShape&quot;, None, &quot;IR3&quot;) onehot_df = onehot(onehot_df, df, &quot;LandContour&quot;, None, &quot;Low&quot;) onehot_df = onehot(onehot_df, df, &quot;LandSlope&quot;, None, &quot;Sev&quot;) onehot_df = onehot(onehot_df, df, &quot;Electrical&quot;, &quot;SBrkr&quot;, &quot;FuseP&quot;) onehot_df = onehot(onehot_df, df, &quot;GarageType&quot;, &quot;None&quot;, &quot;CarPort&quot;) onehot_df = onehot(onehot_df, df, &quot;PavedDrive&quot;, None, &quot;P&quot;) onehot_df = onehot(onehot_df, df, &quot;MiscFeature&quot;, &quot;None&quot;, &quot;Othr&quot;) # Features we can probably ignore (but want to include anyway to see # if they make any positive difference). # Definitely ignoring Utilities: all records are &quot;AllPub&quot;, except for # one &quot;NoSeWa&quot; in the train set and 2 NA in the test set. onehot_df = onehot(onehot_df, df, &quot;Street&quot;, None, &quot;Grvl&quot;) onehot_df = onehot(onehot_df, df, &quot;Alley&quot;, &quot;None&quot;, &quot;Grvl&quot;) onehot_df = onehot(onehot_df, df, &quot;Condition2&quot;, None, &quot;PosA&quot;) onehot_df = onehot(onehot_df, df, &quot;RoofMatl&quot;, None, &quot;WdShake&quot;) onehot_df = onehot(onehot_df, df, &quot;Heating&quot;, None, &quot;Wall&quot;) # I have these as numerical variables too. onehot_df = onehot(onehot_df, df, &quot;ExterQual&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;ExterCond&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtQual&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtCond&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;HeatingQC&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;KitchenQual&quot;, &quot;TA&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;FireplaceQu&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;GarageQual&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;GarageCond&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;PoolQC&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtExposure&quot;, &quot;None&quot;, &quot;Gd&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtFinType1&quot;, &quot;None&quot;, &quot;GLQ&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtFinType2&quot;, &quot;None&quot;, &quot;GLQ&quot;) onehot_df = onehot(onehot_df, df, &quot;Functional&quot;, &quot;Typ&quot;, &quot;Typ&quot;) onehot_df = onehot(onehot_df, df, &quot;GarageFinish&quot;, &quot;None&quot;, &quot;Fin&quot;) onehot_df = onehot(onehot_df, df, &quot;Fence&quot;, &quot;None&quot;, &quot;MnPrv&quot;) onehot_df = onehot(onehot_df, df, &quot;MoSold&quot;, None, None) # Divide up the years between 1871 and 2010 in slices of 20 years. year_map = pd.concat(pd.Series(&quot;YearBin&quot; + str(i+1), index=range(1871+i*20,1891+i*20)) for i in range(0, 7)) yearbin_df = pd.DataFrame(index = df.index) yearbin_df[&quot;GarageYrBltBin&quot;] = df.GarageYrBlt.map(year_map) yearbin_df[&quot;GarageYrBltBin&quot;].fillna(&quot;NoGarage&quot;, inplace=True) yearbin_df[&quot;YearBuiltBin&quot;] = df.YearBuilt.map(year_map) yearbin_df[&quot;YearRemodAddBin&quot;] = df.YearRemodAdd.map(year_map) onehot_df = onehot(onehot_df, yearbin_df, &quot;GarageYrBltBin&quot;, None, None) onehot_df = onehot(onehot_df, yearbin_df, &quot;YearBuiltBin&quot;, None, None) onehot_df = onehot(onehot_df, yearbin_df, &quot;YearRemodAddBin&quot;, None, None) return onehot_df 12345# Add the one-hot encoded categorical features.onehot_df = munge_onehot(train_df)onehot_df = onehot(onehot_df, neighborhood_bin_train, &quot;NeighborhoodBin&quot;, None, None)train_df_munged = train_df_munged.join(onehot_df) 12345678910111213141516171819# These onehot columns are missing in the test data, so drop them from the# training data or we might overfit on them.drop_cols = [ &quot;_Exterior1st_ImStucc&quot;, &quot;_Exterior1st_Stone&quot;, &quot;_Exterior2nd_Other&quot;,&quot;_HouseStyle_2.5Fin&quot;, &quot;_RoofMatl_Membran&quot;, &quot;_RoofMatl_Metal&quot;, &quot;_RoofMatl_Roll&quot;, &quot;_Condition2_RRAe&quot;, &quot;_Condition2_RRAn&quot;, &quot;_Condition2_RRNn&quot;, &quot;_Heating_Floor&quot;, &quot;_Heating_OthW&quot;, &quot;_Electrical_Mix&quot;, &quot;_MiscFeature_TenC&quot;, &quot;_GarageQual_Ex&quot;, &quot;_PoolQC_Fa&quot; ]train_df_munged.drop(drop_cols, axis=1, inplace=True)onehot_df = munge_onehot(test_df)onehot_df = onehot(onehot_df, neighborhood_bin_test, &quot;NeighborhoodBin&quot;, None, None)test_df_munged = test_df_munged.join(onehot_df) 123456789101112# This column is missing in the training data. There is only one example with# this value in the test set. So just drop it.test_df_munged.drop([&quot;_MSSubClass_150&quot;], axis=1, inplace=True)# Drop these columns. They are either not very helpful or they cause overfitting.drop_cols = [ &quot;_Condition2_PosN&quot;, # only two are not zero &quot;_MSZoning_C (all)&quot;, &quot;_MSSubClass_160&quot;,]train_df_munged.drop(drop_cols, axis=1, inplace=True)test_df_munged.drop(drop_cols, axis=1, inplace=True) 123456789# We take the log here because the error metric is between the log of the# SalePrice and the log of the predicted price. That does mean we need to # exp() the prediction to get an actual sale price.label_df = pd.DataFrame(index = train_df_munged.index, columns=[&quot;SalePrice&quot;])label_df[&quot;SalePrice&quot;] = np.log(train_df[&quot;SalePrice&quot;])print(&quot;Training set size:&quot;, train_df_munged.shape)print(&quot;Test set size:&quot;, test_df_munged.shape)y_train = label_df[&quot;SalePrice&quot;].values Training set size: (1456, 403) Test set size: (1459, 403) 123456789101112131415161718192021################################################################################################################################################################################################################################################ 1234#print(&quot;Training set size:&quot;, train_df_munged.shape)#print(&quot;Test set size:&quot;, test_df_munged.shape)y_train = label_df[&quot;SalePrice&quot;].values#train_df_munged.values 12345678910from sklearn.linear_model import ElasticNet, Lasso, BayesianRidge, LassoLarsIC ,Ridgefrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressorfrom sklearn.kernel_ridge import KernelRidgefrom sklearn.pipeline import make_pipelinefrom sklearn.preprocessing import RobustScalerfrom sklearn.base import BaseEstimator, TransformerMixin, RegressorMixin, clonefrom sklearn.model_selection import KFold, cross_val_score, train_test_splitfrom sklearn.metrics import mean_squared_errorimport xgboost as xgbimport lightgbm as lgb 1234567#Validation functionn_folds = 5def rmsle_cv(model): kf = KFold(n_folds, shuffle=True, random_state=42).get_n_splits(train_df_munged.values) rmse= np.sqrt(-cross_val_score(model, train_df_munged.values, y_train, scoring=&quot;neg_mean_squared_error&quot;, cv = kf)) return(rmse) 1lasso = make_pipeline(RobustScaler(), Lasso(alpha =0.0005, random_state=1)) 1ridge = make_pipeline(RobustScaler(), Ridge(alpha =0.0005, random_state=1)) 1ENet = make_pipeline(RobustScaler(), ElasticNet(alpha=0.0005, l1_ratio=.9, random_state=3)) 1KRR = KernelRidge(alpha=0.6, kernel='polynomial', degree=2, coef0=2.5) 1234GBoost = GradientBoostingRegressor(n_estimators=3000, learning_rate=0.05, max_depth=4, max_features='sqrt', min_samples_leaf=15, min_samples_split=10, loss='huber', random_state =5) 123456model_xgb = xgb.XGBRegressor(colsample_bytree=0.4603, gamma=0.0468, learning_rate=0.05, max_depth=3, min_child_weight=1.7817, n_estimators=2200, reg_alpha=0.4640, reg_lambda=0.8571, subsample=0.5213, silent=1, random_state =7, nthread = -1) 1234567model_lgb = lgb.LGBMRegressor(objective='regression',num_leaves=5, learning_rate=0.05, n_estimators=720, max_bin = 55, bagging_fraction = 0.8, bagging_freq = 5, feature_fraction = 0.2319, feature_fraction_seed=9, bagging_seed=9, min_data_in_leaf =6, min_sum_hessian_in_leaf = 11, verbose = '-1') 12score = rmsle_cv(lasso)print(&quot;\\nLasso score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Lasso score: 0.1101 (0.0056) 12score = rmsle_cv(ridge)print(&quot;\\nRidge score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Ridge score: 0.1744 (0.0794) 12score = rmsle_cv(ENet)print(&quot;ElasticNet score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) ElasticNet score: 0.1101 (0.0057) 12score = rmsle_cv(KRR)print(&quot;Kernel Ridge score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Kernel Ridge score: 0.1100 (0.0053) 123score = rmsle_cv(GBoost)print(&quot;Gradient Boosting score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Gradient Boosting score: 0.1146 (0.0070) 12score = rmsle_cv(model_xgb)print(&quot;Xgboost score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Xgboost score: 0.1138 (0.0060) 12score = rmsle_cv(model_lgb)print(&quot;LGBM score: {:.4f} ({:.4f})\\n&quot; .format(score.mean(), score.std())) LGBM score: 0.1151 (0.0052) 1234567891011121314151617181920class AveragingModels(BaseEstimator, RegressorMixin, TransformerMixin): def __init__(self, models): self.models = models # we define clones of the original models to fit the data in def fit(self, X, y): self.models_ = [clone(x) for x in self.models] # Train cloned base models for model in self.models_: model.fit(X, y) return self #Now we do the predictions for cloned models and average them def predict(self, X): predictions = np.column_stack([ model.predict(X) for model in self.models_ ]) return np.mean(predictions, axis=1) 1234averaged_models = AveragingModels(models = (ENet, GBoost, KRR, lasso))score = rmsle_cv(averaged_models)print(&quot; Averaged base models score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Averaged base models score: 0.1077 (0.0057) 1234averaged_models_ridge = AveragingModels(models = (ENet, GBoost, KRR, ridge))score = rmsle_cv(averaged_models_ridge)print(&quot; Averaged base models score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Averaged base models score: 0.1155 (0.0115) 12345678910111213141516171819202122232425262728293031323334class StackingAveragedModels(BaseEstimator, RegressorMixin, TransformerMixin): def __init__(self, base_models, meta_model, n_folds=5): self.base_models = base_models self.meta_model = meta_model self.n_folds = n_folds # We again fit the data on clones of the original models def fit(self, X, y): self.base_models_ = [list() for x in self.base_models] self.meta_model_ = clone(self.meta_model) kfold = KFold(n_splits=self.n_folds, shuffle=True, random_state=156) # Train cloned base models then create out-of-fold predictions # that are needed to train the cloned meta-model out_of_fold_predictions = np.zeros((X.shape[0], len(self.base_models))) for i, model in enumerate(self.base_models): for train_index, holdout_index in kfold.split(X, y): instance = clone(model) self.base_models_[i].append(instance) instance.fit(X[train_index], y[train_index]) y_pred = instance.predict(X[holdout_index]) out_of_fold_predictions[holdout_index, i] = y_pred # Now train the cloned meta-model using the out-of-fold predictions as new feature self.meta_model_.fit(out_of_fold_predictions, y) return self #Do the predictions of all base models on the test data and use the averaged predictions as #meta-features for the final prediction which is done by the meta-model def predict(self, X): meta_features = np.column_stack([ np.column_stack([model.predict(X) for model in base_models]).mean(axis=1) for base_models in self.base_models_ ]) return self.meta_model_.predict(meta_features) 12345stacked_averaged_models = StackingAveragedModels(base_models = (ENet, GBoost, KRR), meta_model = lasso)score = rmsle_cv(stacked_averaged_models)print(&quot;Stacking Averaged models score: {:.4f} ({:.4f})&quot;.format(score.mean(), score.std())) Stacking Averaged models score: 0.1079 (0.0054) 12345stacked_averaged_models_ridge = StackingAveragedModels(base_models = (ENet, GBoost, KRR), meta_model = ridge)score_ridge = rmsle_cv(stacked_averaged_models_ridge)print(&quot;Stacking Averaged models score: {:.4f} ({:.4f})&quot;.format(score_ridge.mean(), score_ridge.std())) Stacking Averaged models score: 0.1079 (0.0054) 12def rmsle(y, y_pred): return np.sqrt(mean_squared_error(y, y_pred)) 1234stacked_averaged_models.fit(train_df_munged.values, y_train)stacked_train_pred = stacked_averaged_models.predict(train_df_munged.values)stacked_pred = np.expm1(stacked_averaged_models.predict(test_df_munged.values))print(rmsle(y_train, stacked_train_pred)) 0.07384935969780994 1234stacked_averaged_models_ridge.fit(train_df_munged.values, y_train)stacked_train_pred_ridge = stacked_averaged_models_ridge.predict(train_df_munged.values)stacked_pred_ridge = np.expm1(stacked_averaged_models_ridge.predict(test_df_munged.values))print(rmsle(y_train, stacked_train_pred_ridge)) 0.07386785761731066 1234model_xgb.fit(train_df_munged, y_train)xgb_train_pred = model_xgb.predict(train_df_munged)xgb_pred = np.expm1(model_xgb.predict(test_df_munged))print(rmsle(y_train, xgb_train_pred)) 0.08404240349359858 1234model_lgb.fit(train_df_munged, y_train)lgb_train_pred = model_lgb.predict(train_df_munged)lgb_pred = np.expm1(model_lgb.predict(test_df_munged.values))print(rmsle(y_train, lgb_train_pred)) 0.06926259332568477 12345'''RMSE on the entire Train data when averaging'''print('RMSLE score on train data:')print(rmsle(y_train,stacked_train_pred*0.7 + xgb_train_pred*0.15 + lgb_train_pred*0.15)) #0.75 0.125 0.125 RMSLE score on train data: 0.07282898327817613 12345'''RMSE on the entire Train data when averaging'''print('RMSLE_ridge score on train data:')print(rmsle(y_train,stacked_train_pred_ridge*0.7 + xgb_train_pred*0.15 + lgb_train_pred*0.15)) RMSLE_ridge score on train data: 0.0728370672457598 1ensemble = stacked_pred*0.85 + xgb_pred*0.075 + lgb_pred*0.075 1ensemble_ridge = stacked_pred_ridge*0.75 + xgb_pred*0.125 + lgb_pred*0.125 12345sub = pd.DataFrame()test_ID = test_df['Id']sub['Id'] = test_IDsub['SalePrice'] = ensemble_ridgesub.to_csv('submission.csv',index=False)","link":"/2024/05/01/copy/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/10/24/hello-world/"},{"title":"oneFunnyDay","text":"today is really good. I had a hang out with my friend Dan, went to burgerKing restaurant and take two spicy burgers.","link":"/2023/11/21/oneFunnyDay/"},{"title":"todayIsSoTired","text":"I feel so tired in mind today because of something unexpected. stewart","link":"/2023/10/28/todayIsSoTired/"},{"title":"todaySoTired","text":"I feel so tired in mind today because of some unecpected and unrelevant family trivias.","link":"/2023/10/28/todaySoTired/"}],"tags":[{"name":"sad","slug":"sad","link":"/tags/sad/"},{"name":"Happy","slug":"Happy","link":"/tags/Happy/"},{"name":"One Plesant Day","slug":"One-Plesant-Day","link":"/tags/One-Plesant-Day/"},{"name":"tired","slug":"tired","link":"/tags/tired/"}],"categories":[{"name":"projects","slug":"projects","link":"/categories/projects/"}],"pages":[{"title":"","text":"12import warningswarnings.filterwarnings('ignore') 123456789101112import numpy as npimport pandas as pd# The error metric: RMSE on the log of the sale prices.from sklearn.metrics import mean_squared_errordef rmse(y_true, y_pred): return np.sqrt(mean_squared_error(y_true, y_pred))# Load the data.train_df = pd.read_csv(&quot;/kaggle/input/house-price/train.csv&quot;)test_df = pd.read_csv(&quot;/kaggle/input/house-price/test.csv&quot;) 12345678910111213141516171819# There are a few houses with more than 4000 sq ft living area that are# outliers, so we drop them from the training data. (There is also one in# the test set but we obviously can't drop that one.)train_df.drop(train_df[train_df[&quot;GrLivArea&quot;] &gt; 4000].index, inplace=True)# The test example with ID 666 has GarageArea, GarageCars, and GarageType # but none of the other fields, so use the mode and median to fill them in.test_df.loc[666, &quot;GarageQual&quot;] = &quot;TA&quot;test_df.loc[666, &quot;GarageCond&quot;] = &quot;TA&quot;test_df.loc[666, &quot;GarageFinish&quot;] = &quot;Unf&quot;test_df.loc[666, &quot;GarageYrBlt&quot;] = &quot;1980&quot;# The test example 1116 only has GarageType but no other information. We'll # assume it does not have a garage.test_df.loc[1116, &quot;GarageType&quot;] = np.nan# For imputing missing values: fill in missing LotFrontage values by the median# LotFrontage of the neighborhood.lot_frontage_by_neighborhood = train_df[&quot;LotFrontage&quot;].groupby(train_df[&quot;Neighborhood&quot;]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288# Used to convert categorical features into ordinal numbers.# (There's probably an easier way to do this, but it works.)from sklearn.preprocessing import LabelEncoderle = LabelEncoder()def factorize(df, factor_df, column, fill_na=None): factor_df[column] = df[column] if fill_na is not None: factor_df[column].fillna(fill_na, inplace=True) le.fit(factor_df[column].unique()) factor_df[column] = le.transform(factor_df[column]) return factor_df# Combine all the (numerical) features into one big DataFrame. We don't add # the one-hot encoded variables here yet, that happens later on.def munge(df): all_df = pd.DataFrame(index = df.index) all_df[&quot;LotFrontage&quot;] = df[&quot;LotFrontage&quot;] for key, group in lot_frontage_by_neighborhood: idx = (df[&quot;Neighborhood&quot;] == key) &amp; (df[&quot;LotFrontage&quot;].isnull()) all_df.loc[idx, &quot;LotFrontage&quot;] = group.median() all_df[&quot;LotArea&quot;] = df[&quot;LotArea&quot;] all_df[&quot;MasVnrArea&quot;] = df[&quot;MasVnrArea&quot;] all_df[&quot;MasVnrArea&quot;].fillna(0, inplace=True) all_df[&quot;BsmtFinSF1&quot;] = df[&quot;BsmtFinSF1&quot;] all_df[&quot;BsmtFinSF1&quot;].fillna(0, inplace=True) all_df[&quot;BsmtFinSF2&quot;] = df[&quot;BsmtFinSF2&quot;] all_df[&quot;BsmtFinSF2&quot;].fillna(0, inplace=True) all_df[&quot;BsmtUnfSF&quot;] = df[&quot;BsmtUnfSF&quot;] all_df[&quot;BsmtUnfSF&quot;].fillna(0, inplace=True) all_df[&quot;TotalBsmtSF&quot;] = df[&quot;TotalBsmtSF&quot;] all_df[&quot;TotalBsmtSF&quot;].fillna(0, inplace=True) all_df[&quot;1stFlrSF&quot;] = df[&quot;1stFlrSF&quot;] all_df[&quot;2ndFlrSF&quot;] = df[&quot;2ndFlrSF&quot;] all_df[&quot;GrLivArea&quot;] = df[&quot;GrLivArea&quot;] all_df[&quot;GarageArea&quot;] = df[&quot;GarageArea&quot;] all_df[&quot;GarageArea&quot;].fillna(0, inplace=True) all_df[&quot;WoodDeckSF&quot;] = df[&quot;WoodDeckSF&quot;] all_df[&quot;OpenPorchSF&quot;] = df[&quot;OpenPorchSF&quot;] all_df[&quot;EnclosedPorch&quot;] = df[&quot;EnclosedPorch&quot;] all_df[&quot;3SsnPorch&quot;] = df[&quot;3SsnPorch&quot;] all_df[&quot;ScreenPorch&quot;] = df[&quot;ScreenPorch&quot;] all_df[&quot;BsmtFullBath&quot;] = df[&quot;BsmtFullBath&quot;] all_df[&quot;BsmtFullBath&quot;].fillna(0, inplace=True) all_df[&quot;BsmtHalfBath&quot;] = df[&quot;BsmtHalfBath&quot;] all_df[&quot;BsmtHalfBath&quot;].fillna(0, inplace=True) all_df[&quot;FullBath&quot;] = df[&quot;FullBath&quot;] all_df[&quot;HalfBath&quot;] = df[&quot;HalfBath&quot;] all_df[&quot;BedroomAbvGr&quot;] = df[&quot;BedroomAbvGr&quot;] all_df[&quot;KitchenAbvGr&quot;] = df[&quot;KitchenAbvGr&quot;] all_df[&quot;TotRmsAbvGrd&quot;] = df[&quot;TotRmsAbvGrd&quot;] all_df[&quot;Fireplaces&quot;] = df[&quot;Fireplaces&quot;] all_df[&quot;GarageCars&quot;] = df[&quot;GarageCars&quot;] all_df[&quot;GarageCars&quot;].fillna(0, inplace=True) all_df[&quot;CentralAir&quot;] = (df[&quot;CentralAir&quot;] == &quot;Y&quot;) * 1.0 all_df[&quot;OverallQual&quot;] = df[&quot;OverallQual&quot;] all_df[&quot;OverallCond&quot;] = df[&quot;OverallCond&quot;] # Quality measurements are stored as text but we can convert them to # numbers where a higher number means higher quality. qual_dict = {np.nan: 0, &quot;Po&quot;: 1, &quot;Fa&quot;: 2, &quot;TA&quot;: 3, &quot;Gd&quot;: 4, &quot;Ex&quot;: 5} all_df[&quot;ExterQual&quot;] = df[&quot;ExterQual&quot;].map(qual_dict).astype(int) all_df[&quot;ExterCond&quot;] = df[&quot;ExterCond&quot;].map(qual_dict).astype(int) all_df[&quot;BsmtQual&quot;] = df[&quot;BsmtQual&quot;].map(qual_dict).astype(int)# all_df[&quot;BsmtCond&quot;] = df[&quot;BsmtCond&quot;].map(qual_dict).astype(int)# all_df[&quot;HeatingQC&quot;] = df[&quot;HeatingQC&quot;].map(qual_dict).astype(int) all_df[&quot;KitchenQual&quot;] = df[&quot;KitchenQual&quot;].map(qual_dict).astype(int) all_df[&quot;FireplaceQu&quot;] = df[&quot;FireplaceQu&quot;].map(qual_dict).astype(int)# all_df[&quot;GarageQual&quot;] = df[&quot;GarageQual&quot;].map(qual_dict).astype(int)# all_df[&quot;GarageCond&quot;] = df[&quot;GarageCond&quot;].map(qual_dict).astype(int)# all_df[&quot;BsmtExposure&quot;] = df[&quot;BsmtExposure&quot;].map( {np.nan: 0, &quot;No&quot;: 1, &quot;Mn&quot;: 2, &quot;Av&quot;: 3, &quot;Gd&quot;: 4}).astype(int) bsmt_fin_dict = {np.nan: 0, &quot;Unf&quot;: 1, &quot;LwQ&quot;: 2, &quot;Rec&quot;: 3, &quot;BLQ&quot;: 4, &quot;ALQ&quot;: 5, &quot;GLQ&quot;: 6} all_df[&quot;BsmtFinType1&quot;] = df[&quot;BsmtFinType1&quot;].map(bsmt_fin_dict).astype(int) all_df[&quot;BsmtFinType2&quot;] = df[&quot;BsmtFinType2&quot;].map(bsmt_fin_dict).astype(int) all_df[&quot;Functional&quot;] = df[&quot;Functional&quot;].map( {np.nan: 0, &quot;Sal&quot;: 1, &quot;Sev&quot;: 2, &quot;Maj2&quot;: 3, &quot;Maj1&quot;: 4, &quot;Mod&quot;: 5, &quot;Min2&quot;: 6, &quot;Min1&quot;: 7, &quot;Typ&quot;: 8}).astype(int) all_df[&quot;GarageFinish&quot;] = df[&quot;GarageFinish&quot;].map( {np.nan: 0, &quot;Unf&quot;: 1, &quot;RFn&quot;: 2, &quot;Fin&quot;: 3}).astype(int) all_df[&quot;Fence&quot;] = df[&quot;Fence&quot;].map( {np.nan: 0, &quot;MnWw&quot;: 1, &quot;GdWo&quot;: 2, &quot;MnPrv&quot;: 3, &quot;GdPrv&quot;: 4}).astype(int) all_df[&quot;YearBuilt&quot;] = df[&quot;YearBuilt&quot;] all_df[&quot;YearRemodAdd&quot;] = df[&quot;YearRemodAdd&quot;] all_df[&quot;GarageYrBlt&quot;] = df[&quot;GarageYrBlt&quot;] all_df[&quot;GarageYrBlt&quot;].fillna(0.0, inplace=True) all_df[&quot;MoSold&quot;] = df[&quot;MoSold&quot;] all_df[&quot;YrSold&quot;] = df[&quot;YrSold&quot;] all_df[&quot;LowQualFinSF&quot;] = df[&quot;LowQualFinSF&quot;] all_df[&quot;MiscVal&quot;] = df[&quot;MiscVal&quot;] # df[&quot;PoolQC&quot;].fillna(&quot;NA&quot;, inplace=True) # all_df[&quot;PoolQC&quot;] = df[&quot;PoolQC&quot;].map(qual_dict).astype(int)# all_df[&quot;PoolArea&quot;] = df[&quot;PoolArea&quot;] all_df[&quot;PoolArea&quot;].fillna(0, inplace=True) # Add categorical features as numbers too. It seems to help a bit. all_df = factorize(df, all_df, &quot;MSSubClass&quot;) all_df = factorize(df, all_df, &quot;MSZoning&quot;, &quot;RL&quot;) all_df = factorize(df, all_df, &quot;LotConfig&quot;) all_df = factorize(df, all_df, &quot;Neighborhood&quot;) all_df = factorize(df, all_df, &quot;Condition1&quot;) all_df = factorize(df, all_df, &quot;BldgType&quot;) all_df = factorize(df, all_df, &quot;HouseStyle&quot;) all_df = factorize(df, all_df, &quot;RoofStyle&quot;) all_df = factorize(df, all_df, &quot;Exterior1st&quot;, &quot;Other&quot;) all_df = factorize(df, all_df, &quot;Exterior2nd&quot;, &quot;Other&quot;) all_df = factorize(df, all_df, &quot;MasVnrType&quot;, &quot;None&quot;) all_df = factorize(df, all_df, &quot;Foundation&quot;) all_df = factorize(df, all_df, &quot;SaleType&quot;, &quot;Oth&quot;) all_df = factorize(df, all_df, &quot;SaleCondition&quot;) # IR2 and IR3 don't appear that often, so just make a distinction # between regular and irregular. all_df[&quot;IsRegularLotShape&quot;] = (df[&quot;LotShape&quot;] == &quot;Reg&quot;) * 1 # Most properties are level; bin the other possibilities together # as &quot;not level&quot;. all_df[&quot;IsLandLevel&quot;] = (df[&quot;LandContour&quot;] == &quot;Lvl&quot;) * 1 # Most land slopes are gentle; treat the others as &quot;not gentle&quot;. all_df[&quot;IsLandSlopeGentle&quot;] = (df[&quot;LandSlope&quot;] == &quot;Gtl&quot;) * 1 # Most properties use standard circuit breakers. all_df[&quot;IsElectricalSBrkr&quot;] = (df[&quot;Electrical&quot;] == &quot;SBrkr&quot;) * 1 # About 2/3rd have an attached garage. all_df[&quot;IsGarageDetached&quot;] = (df[&quot;GarageType&quot;] == &quot;Detchd&quot;) * 1 # Most have a paved drive. Treat dirt/gravel and partial pavement # as &quot;not paved&quot;. all_df[&quot;IsPavedDrive&quot;] = (df[&quot;PavedDrive&quot;] == &quot;Y&quot;) * 1 # The only interesting &quot;misc. feature&quot; is the presence of a shed. all_df[&quot;HasShed&quot;] = (df[&quot;MiscFeature&quot;] == &quot;Shed&quot;) * 1. # If YearRemodAdd != YearBuilt, then a remodeling took place at some point. all_df[&quot;Remodeled&quot;] = (all_df[&quot;YearRemodAdd&quot;] != all_df[&quot;YearBuilt&quot;]) * 1 # Did a remodeling happen in the year the house was sold? all_df[&quot;RecentRemodel&quot;] = (all_df[&quot;YearRemodAdd&quot;] == all_df[&quot;YrSold&quot;]) * 1 # Was this house sold in the year it was built? all_df[&quot;VeryNewHouse&quot;] = (all_df[&quot;YearBuilt&quot;] == all_df[&quot;YrSold&quot;]) * 1 all_df[&quot;Has2ndFloor&quot;] = (all_df[&quot;2ndFlrSF&quot;] == 0) * 1 all_df[&quot;HasMasVnr&quot;] = (all_df[&quot;MasVnrArea&quot;] == 0) * 1 all_df[&quot;HasWoodDeck&quot;] = (all_df[&quot;WoodDeckSF&quot;] == 0) * 1 all_df[&quot;HasOpenPorch&quot;] = (all_df[&quot;OpenPorchSF&quot;] == 0) * 1 all_df[&quot;HasEnclosedPorch&quot;] = (all_df[&quot;EnclosedPorch&quot;] == 0) * 1 all_df[&quot;Has3SsnPorch&quot;] = (all_df[&quot;3SsnPorch&quot;] == 0) * 1 all_df[&quot;HasScreenPorch&quot;] = (all_df[&quot;ScreenPorch&quot;] == 0) * 1 # Months with the largest number of deals may be significant. all_df[&quot;HighSeason&quot;] = df[&quot;MoSold&quot;].replace( {1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0}) all_df[&quot;NewerDwelling&quot;] = df[&quot;MSSubClass&quot;].replace( {20: 1, 30: 0, 40: 0, 45: 0,50: 0, 60: 1, 70: 0, 75: 0, 80: 0, 85: 0, 90: 0, 120: 1, 150: 0, 160: 0, 180: 0, 190: 0}) all_df.loc[df.Neighborhood == 'NridgHt', &quot;Neighborhood_Good&quot;] = 1 all_df.loc[df.Neighborhood == 'Crawfor', &quot;Neighborhood_Good&quot;] = 1 all_df.loc[df.Neighborhood == 'StoneBr', &quot;Neighborhood_Good&quot;] = 1 all_df.loc[df.Neighborhood == 'Somerst', &quot;Neighborhood_Good&quot;] = 1 all_df.loc[df.Neighborhood == 'NoRidge', &quot;Neighborhood_Good&quot;] = 1 all_df[&quot;Neighborhood_Good&quot;].fillna(0, inplace=True) all_df[&quot;SaleCondition_PriceDown&quot;] = df.SaleCondition.replace( {'Abnorml': 1, 'Alloca': 1, 'AdjLand': 1, 'Family': 1, 'Normal': 0, 'Partial': 0}) # House completed before sale or not all_df[&quot;BoughtOffPlan&quot;] = df.SaleCondition.replace( {&quot;Abnorml&quot; : 0, &quot;Alloca&quot; : 0, &quot;AdjLand&quot; : 0, &quot;Family&quot; : 0, &quot;Normal&quot; : 0, &quot;Partial&quot; : 1}) all_df[&quot;BadHeating&quot;] = df.HeatingQC.replace( {'Ex': 0, 'Gd': 0, 'TA': 0, 'Fa': 1, 'Po': 1}) area_cols = ['LotFrontage', 'LotArea', 'MasVnrArea', 'BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF', 'TotalBsmtSF', '1stFlrSF', '2ndFlrSF', 'GrLivArea', 'GarageArea', 'WoodDeckSF', 'OpenPorchSF', 'EnclosedPorch', '3SsnPorch', 'ScreenPorch', 'LowQualFinSF', 'PoolArea' ] all_df[&quot;TotalArea&quot;] = all_df[area_cols].sum(axis=1) all_df[&quot;TotalArea1st2nd&quot;] = all_df[&quot;1stFlrSF&quot;] + all_df[&quot;2ndFlrSF&quot;] all_df[&quot;Age&quot;] = 2010 - all_df[&quot;YearBuilt&quot;] all_df[&quot;TimeSinceSold&quot;] = 2010 - all_df[&quot;YrSold&quot;] all_df[&quot;SeasonSold&quot;] = all_df[&quot;MoSold&quot;].map({12:0, 1:0, 2:0, 3:1, 4:1, 5:1, 6:2, 7:2, 8:2, 9:3, 10:3, 11:3}).astype(int) all_df[&quot;YearsSinceRemodel&quot;] = all_df[&quot;YrSold&quot;] - all_df[&quot;YearRemodAdd&quot;] # Simplifications of existing features into bad/average/good. all_df[&quot;SimplOverallQual&quot;] = all_df.OverallQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2, 6 : 2, 7 : 3, 8 : 3, 9 : 3, 10 : 3}) all_df[&quot;SimplOverallCond&quot;] = all_df.OverallCond.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2, 6 : 2, 7 : 3, 8 : 3, 9 : 3, 10 : 3}) all_df[&quot;SimplPoolQC&quot;] = all_df.PoolQC.replace( {1 : 1, 2 : 1, 3 : 2, 4 : 2}) all_df[&quot;SimplGarageCond&quot;] = all_df.GarageCond.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplGarageQual&quot;] = all_df.GarageQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplFireplaceQu&quot;] = all_df.FireplaceQu.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplFireplaceQu&quot;] = all_df.FireplaceQu.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplFunctional&quot;] = all_df.Functional.replace( {1 : 1, 2 : 1, 3 : 2, 4 : 2, 5 : 3, 6 : 3, 7 : 3, 8 : 4}) all_df[&quot;SimplKitchenQual&quot;] = all_df.KitchenQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplHeatingQC&quot;] = all_df.HeatingQC.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplBsmtFinType1&quot;] = all_df.BsmtFinType1.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2, 6 : 2}) all_df[&quot;SimplBsmtFinType2&quot;] = all_df.BsmtFinType2.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2, 6 : 2}) all_df[&quot;SimplBsmtCond&quot;] = all_df.BsmtCond.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplBsmtQual&quot;] = all_df.BsmtQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplExterCond&quot;] = all_df.ExterCond.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) all_df[&quot;SimplExterQual&quot;] = all_df.ExterQual.replace( {1 : 1, 2 : 1, 3 : 1, 4 : 2, 5 : 2}) # Bin by neighborhood (a little arbitrarily). Values were computed by: # train_df[&quot;SalePrice&quot;].groupby(train_df[&quot;Neighborhood&quot;]).median().sort_values() neighborhood_map = { &quot;MeadowV&quot; : 0, # 88000 &quot;IDOTRR&quot; : 1, # 103000 &quot;BrDale&quot; : 1, # 106000 &quot;OldTown&quot; : 1, # 119000 &quot;Edwards&quot; : 1, # 119500 &quot;BrkSide&quot; : 1, # 124300 &quot;Sawyer&quot; : 1, # 135000 &quot;Blueste&quot; : 1, # 137500 &quot;SWISU&quot; : 2, # 139500 &quot;NAmes&quot; : 2, # 140000 &quot;NPkVill&quot; : 2, # 146000 &quot;Mitchel&quot; : 2, # 153500 &quot;SawyerW&quot; : 2, # 179900 &quot;Gilbert&quot; : 2, # 181000 &quot;NWAmes&quot; : 2, # 182900 &quot;Blmngtn&quot; : 2, # 191000 &quot;CollgCr&quot; : 2, # 197200 &quot;ClearCr&quot; : 3, # 200250 &quot;Crawfor&quot; : 3, # 200624 &quot;Veenker&quot; : 3, # 218000 &quot;Somerst&quot; : 3, # 225500 &quot;Timber&quot; : 3, # 228475 &quot;StoneBr&quot; : 4, # 278000 &quot;NoRidge&quot; : 4, # 290000 &quot;NridgHt&quot; : 4, # 315000 } all_df[&quot;NeighborhoodBin&quot;] = df[&quot;Neighborhood&quot;].map(neighborhood_map) return all_df 12345678910111213train_df_munged = munge(train_df)test_df_munged = munge(test_df)print(train_df_munged.shape)print(test_df_munged.shape)# Copy NeighborhoodBin into a temporary DataFrame because we want to use the# unscaled version later on (to one-hot encode it). neighborhood_bin_train = pd.DataFrame(index = train_df.index)neighborhood_bin_train[&quot;NeighborhoodBin&quot;] = train_df_munged[&quot;NeighborhoodBin&quot;]neighborhood_bin_test = pd.DataFrame(index = test_df.index)neighborhood_bin_test[&quot;NeighborhoodBin&quot;] = test_df_munged[&quot;NeighborhoodBin&quot;] (1456, 111) (1459, 111) 12345678910111213141516171819202122232425numeric_features = train_df_munged.dtypes[train_df_munged.dtypes != &quot;object&quot;].index# Transform the skewed numeric features by taking log(feature + 1).# This will make the features more normal.from scipy.stats import skewskewed = train_df_munged[numeric_features].apply(lambda x: skew(x.dropna().astype(float)))skewed = skewed[skewed &gt; 0.75]skewed = skewed.indextrain_df_munged[skewed] = np.log1p(train_df_munged[skewed])test_df_munged[skewed] = np.log1p(test_df_munged[skewed])# Additional processing: scale the data. from sklearn.preprocessing import StandardScalerscaler = StandardScaler()scaler.fit(train_df_munged[numeric_features])scaled = scaler.transform(train_df_munged[numeric_features])for i, col in enumerate(numeric_features): train_df_munged[col] = scaled[:, i]scaled = scaler.transform(test_df_munged[numeric_features])for i, col in enumerate(numeric_features): test_df_munged[col] = scaled[:, i] 123456789101112131415# Convert categorical features using one-hot encoding.def onehot(onehot_df, df, column_name, fill_na, drop_name): onehot_df[column_name] = df[column_name] if fill_na is not None: onehot_df[column_name].fillna(fill_na, inplace=True) dummies = pd.get_dummies(onehot_df[column_name], prefix=&quot;_&quot; + column_name) # Dropping one of the columns actually made the results slightly worse. # if drop_name is not None: # dummies.drop([&quot;_&quot; + column_name + &quot;_&quot; + drop_name], axis=1, inplace=True) onehot_df = onehot_df.join(dummies) onehot_df = onehot_df.drop([column_name], axis=1) return onehot_df 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576def munge_onehot(df): onehot_df = pd.DataFrame(index = df.index) onehot_df = onehot(onehot_df, df, &quot;MSSubClass&quot;, None, &quot;40&quot;) onehot_df = onehot(onehot_df, df, &quot;MSZoning&quot;, &quot;RL&quot;, &quot;RH&quot;) onehot_df = onehot(onehot_df, df, &quot;LotConfig&quot;, None, &quot;FR3&quot;) onehot_df = onehot(onehot_df, df, &quot;Neighborhood&quot;, None, &quot;OldTown&quot;) onehot_df = onehot(onehot_df, df, &quot;Condition1&quot;, None, &quot;RRNe&quot;) onehot_df = onehot(onehot_df, df, &quot;BldgType&quot;, None, &quot;2fmCon&quot;) onehot_df = onehot(onehot_df, df, &quot;HouseStyle&quot;, None, &quot;1.5Unf&quot;) onehot_df = onehot(onehot_df, df, &quot;RoofStyle&quot;, None, &quot;Shed&quot;) onehot_df = onehot(onehot_df, df, &quot;Exterior1st&quot;, &quot;VinylSd&quot;, &quot;CBlock&quot;) onehot_df = onehot(onehot_df, df, &quot;Exterior2nd&quot;, &quot;VinylSd&quot;, &quot;CBlock&quot;) onehot_df = onehot(onehot_df, df, &quot;Foundation&quot;, None, &quot;Wood&quot;) onehot_df = onehot(onehot_df, df, &quot;SaleType&quot;, &quot;WD&quot;, &quot;Oth&quot;) onehot_df = onehot(onehot_df, df, &quot;SaleCondition&quot;, &quot;Normal&quot;, &quot;AdjLand&quot;) # Fill in missing MasVnrType for rows that do have a MasVnrArea. temp_df = df[[&quot;MasVnrType&quot;, &quot;MasVnrArea&quot;]].copy() idx = (df[&quot;MasVnrArea&quot;] != 0) &amp; ((df[&quot;MasVnrType&quot;] == &quot;None&quot;) | (df[&quot;MasVnrType&quot;].isnull())) temp_df.loc[idx, &quot;MasVnrType&quot;] = &quot;BrkFace&quot; onehot_df = onehot(onehot_df, temp_df, &quot;MasVnrType&quot;, &quot;None&quot;, &quot;BrkCmn&quot;) # Also add the booleans from calc_df as dummy variables. onehot_df = onehot(onehot_df, df, &quot;LotShape&quot;, None, &quot;IR3&quot;) onehot_df = onehot(onehot_df, df, &quot;LandContour&quot;, None, &quot;Low&quot;) onehot_df = onehot(onehot_df, df, &quot;LandSlope&quot;, None, &quot;Sev&quot;) onehot_df = onehot(onehot_df, df, &quot;Electrical&quot;, &quot;SBrkr&quot;, &quot;FuseP&quot;) onehot_df = onehot(onehot_df, df, &quot;GarageType&quot;, &quot;None&quot;, &quot;CarPort&quot;) onehot_df = onehot(onehot_df, df, &quot;PavedDrive&quot;, None, &quot;P&quot;) onehot_df = onehot(onehot_df, df, &quot;MiscFeature&quot;, &quot;None&quot;, &quot;Othr&quot;) # Features we can probably ignore (but want to include anyway to see # if they make any positive difference). # Definitely ignoring Utilities: all records are &quot;AllPub&quot;, except for # one &quot;NoSeWa&quot; in the train set and 2 NA in the test set. onehot_df = onehot(onehot_df, df, &quot;Street&quot;, None, &quot;Grvl&quot;) onehot_df = onehot(onehot_df, df, &quot;Alley&quot;, &quot;None&quot;, &quot;Grvl&quot;) onehot_df = onehot(onehot_df, df, &quot;Condition2&quot;, None, &quot;PosA&quot;) onehot_df = onehot(onehot_df, df, &quot;RoofMatl&quot;, None, &quot;WdShake&quot;) onehot_df = onehot(onehot_df, df, &quot;Heating&quot;, None, &quot;Wall&quot;) # I have these as numerical variables too. onehot_df = onehot(onehot_df, df, &quot;ExterQual&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;ExterCond&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtQual&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtCond&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;HeatingQC&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;KitchenQual&quot;, &quot;TA&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;FireplaceQu&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;GarageQual&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;GarageCond&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;PoolQC&quot;, &quot;None&quot;, &quot;Ex&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtExposure&quot;, &quot;None&quot;, &quot;Gd&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtFinType1&quot;, &quot;None&quot;, &quot;GLQ&quot;) onehot_df = onehot(onehot_df, df, &quot;BsmtFinType2&quot;, &quot;None&quot;, &quot;GLQ&quot;) onehot_df = onehot(onehot_df, df, &quot;Functional&quot;, &quot;Typ&quot;, &quot;Typ&quot;) onehot_df = onehot(onehot_df, df, &quot;GarageFinish&quot;, &quot;None&quot;, &quot;Fin&quot;) onehot_df = onehot(onehot_df, df, &quot;Fence&quot;, &quot;None&quot;, &quot;MnPrv&quot;) onehot_df = onehot(onehot_df, df, &quot;MoSold&quot;, None, None) # Divide up the years between 1871 and 2010 in slices of 20 years. year_map = pd.concat(pd.Series(&quot;YearBin&quot; + str(i+1), index=range(1871+i*20,1891+i*20)) for i in range(0, 7)) yearbin_df = pd.DataFrame(index = df.index) yearbin_df[&quot;GarageYrBltBin&quot;] = df.GarageYrBlt.map(year_map) yearbin_df[&quot;GarageYrBltBin&quot;].fillna(&quot;NoGarage&quot;, inplace=True) yearbin_df[&quot;YearBuiltBin&quot;] = df.YearBuilt.map(year_map) yearbin_df[&quot;YearRemodAddBin&quot;] = df.YearRemodAdd.map(year_map) onehot_df = onehot(onehot_df, yearbin_df, &quot;GarageYrBltBin&quot;, None, None) onehot_df = onehot(onehot_df, yearbin_df, &quot;YearBuiltBin&quot;, None, None) onehot_df = onehot(onehot_df, yearbin_df, &quot;YearRemodAddBin&quot;, None, None) return onehot_df 12345# Add the one-hot encoded categorical features.onehot_df = munge_onehot(train_df)onehot_df = onehot(onehot_df, neighborhood_bin_train, &quot;NeighborhoodBin&quot;, None, None)train_df_munged = train_df_munged.join(onehot_df) 12345678910111213141516171819# These onehot columns are missing in the test data, so drop them from the# training data or we might overfit on them.drop_cols = [ &quot;_Exterior1st_ImStucc&quot;, &quot;_Exterior1st_Stone&quot;, &quot;_Exterior2nd_Other&quot;,&quot;_HouseStyle_2.5Fin&quot;, &quot;_RoofMatl_Membran&quot;, &quot;_RoofMatl_Metal&quot;, &quot;_RoofMatl_Roll&quot;, &quot;_Condition2_RRAe&quot;, &quot;_Condition2_RRAn&quot;, &quot;_Condition2_RRNn&quot;, &quot;_Heating_Floor&quot;, &quot;_Heating_OthW&quot;, &quot;_Electrical_Mix&quot;, &quot;_MiscFeature_TenC&quot;, &quot;_GarageQual_Ex&quot;, &quot;_PoolQC_Fa&quot; ]train_df_munged.drop(drop_cols, axis=1, inplace=True)onehot_df = munge_onehot(test_df)onehot_df = onehot(onehot_df, neighborhood_bin_test, &quot;NeighborhoodBin&quot;, None, None)test_df_munged = test_df_munged.join(onehot_df) 123456789101112# This column is missing in the training data. There is only one example with# this value in the test set. So just drop it.test_df_munged.drop([&quot;_MSSubClass_150&quot;], axis=1, inplace=True)# Drop these columns. They are either not very helpful or they cause overfitting.drop_cols = [ &quot;_Condition2_PosN&quot;, # only two are not zero &quot;_MSZoning_C (all)&quot;, &quot;_MSSubClass_160&quot;,]train_df_munged.drop(drop_cols, axis=1, inplace=True)test_df_munged.drop(drop_cols, axis=1, inplace=True) 123456789# We take the log here because the error metric is between the log of the# SalePrice and the log of the predicted price. That does mean we need to # exp() the prediction to get an actual sale price.label_df = pd.DataFrame(index = train_df_munged.index, columns=[&quot;SalePrice&quot;])label_df[&quot;SalePrice&quot;] = np.log(train_df[&quot;SalePrice&quot;])print(&quot;Training set size:&quot;, train_df_munged.shape)print(&quot;Test set size:&quot;, test_df_munged.shape)y_train = label_df[&quot;SalePrice&quot;].values Training set size: (1456, 403) Test set size: (1459, 403) 123456789101112131415161718192021################################################################################################################################################################################################################################################ 1234#print(&quot;Training set size:&quot;, train_df_munged.shape)#print(&quot;Test set size:&quot;, test_df_munged.shape)y_train = label_df[&quot;SalePrice&quot;].values#train_df_munged.values 12345678910from sklearn.linear_model import ElasticNet, Lasso, BayesianRidge, LassoLarsIC ,Ridgefrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressorfrom sklearn.kernel_ridge import KernelRidgefrom sklearn.pipeline import make_pipelinefrom sklearn.preprocessing import RobustScalerfrom sklearn.base import BaseEstimator, TransformerMixin, RegressorMixin, clonefrom sklearn.model_selection import KFold, cross_val_score, train_test_splitfrom sklearn.metrics import mean_squared_errorimport xgboost as xgbimport lightgbm as lgb 1234567#Validation functionn_folds = 5def rmsle_cv(model): kf = KFold(n_folds, shuffle=True, random_state=42).get_n_splits(train_df_munged.values) rmse= np.sqrt(-cross_val_score(model, train_df_munged.values, y_train, scoring=&quot;neg_mean_squared_error&quot;, cv = kf)) return(rmse) 1lasso = make_pipeline(RobustScaler(), Lasso(alpha =0.0005, random_state=1)) 1ridge = make_pipeline(RobustScaler(), Ridge(alpha =0.0005, random_state=1)) 1ENet = make_pipeline(RobustScaler(), ElasticNet(alpha=0.0005, l1_ratio=.9, random_state=3)) 1KRR = KernelRidge(alpha=0.6, kernel='polynomial', degree=2, coef0=2.5) 1234GBoost = GradientBoostingRegressor(n_estimators=3000, learning_rate=0.05, max_depth=4, max_features='sqrt', min_samples_leaf=15, min_samples_split=10, loss='huber', random_state =5) 123456model_xgb = xgb.XGBRegressor(colsample_bytree=0.4603, gamma=0.0468, learning_rate=0.05, max_depth=3, min_child_weight=1.7817, n_estimators=2200, reg_alpha=0.4640, reg_lambda=0.8571, subsample=0.5213, silent=1, random_state =7, nthread = -1) 1234567model_lgb = lgb.LGBMRegressor(objective='regression',num_leaves=5, learning_rate=0.05, n_estimators=720, max_bin = 55, bagging_fraction = 0.8, bagging_freq = 5, feature_fraction = 0.2319, feature_fraction_seed=9, bagging_seed=9, min_data_in_leaf =6, min_sum_hessian_in_leaf = 11, verbose = '-1') 12score = rmsle_cv(lasso)print(&quot;\\nLasso score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Lasso score: 0.1101 (0.0056) 12score = rmsle_cv(ridge)print(&quot;\\nRidge score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Ridge score: 0.1744 (0.0794) 12score = rmsle_cv(ENet)print(&quot;ElasticNet score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) ElasticNet score: 0.1101 (0.0057) 12score = rmsle_cv(KRR)print(&quot;Kernel Ridge score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Kernel Ridge score: 0.1100 (0.0053) 123score = rmsle_cv(GBoost)print(&quot;Gradient Boosting score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Gradient Boosting score: 0.1146 (0.0070) 12score = rmsle_cv(model_xgb)print(&quot;Xgboost score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Xgboost score: 0.1138 (0.0060) 12score = rmsle_cv(model_lgb)print(&quot;LGBM score: {:.4f} ({:.4f})\\n&quot; .format(score.mean(), score.std())) LGBM score: 0.1151 (0.0052) 1234567891011121314151617181920class AveragingModels(BaseEstimator, RegressorMixin, TransformerMixin): def __init__(self, models): self.models = models # we define clones of the original models to fit the data in def fit(self, X, y): self.models_ = [clone(x) for x in self.models] # Train cloned base models for model in self.models_: model.fit(X, y) return self #Now we do the predictions for cloned models and average them def predict(self, X): predictions = np.column_stack([ model.predict(X) for model in self.models_ ]) return np.mean(predictions, axis=1) 1234averaged_models = AveragingModels(models = (ENet, GBoost, KRR, lasso))score = rmsle_cv(averaged_models)print(&quot; Averaged base models score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Averaged base models score: 0.1077 (0.0057) 1234averaged_models_ridge = AveragingModels(models = (ENet, GBoost, KRR, ridge))score = rmsle_cv(averaged_models_ridge)print(&quot; Averaged base models score: {:.4f} ({:.4f})\\n&quot;.format(score.mean(), score.std())) Averaged base models score: 0.1155 (0.0115) 12345678910111213141516171819202122232425262728293031323334class StackingAveragedModels(BaseEstimator, RegressorMixin, TransformerMixin): def __init__(self, base_models, meta_model, n_folds=5): self.base_models = base_models self.meta_model = meta_model self.n_folds = n_folds # We again fit the data on clones of the original models def fit(self, X, y): self.base_models_ = [list() for x in self.base_models] self.meta_model_ = clone(self.meta_model) kfold = KFold(n_splits=self.n_folds, shuffle=True, random_state=156) # Train cloned base models then create out-of-fold predictions # that are needed to train the cloned meta-model out_of_fold_predictions = np.zeros((X.shape[0], len(self.base_models))) for i, model in enumerate(self.base_models): for train_index, holdout_index in kfold.split(X, y): instance = clone(model) self.base_models_[i].append(instance) instance.fit(X[train_index], y[train_index]) y_pred = instance.predict(X[holdout_index]) out_of_fold_predictions[holdout_index, i] = y_pred # Now train the cloned meta-model using the out-of-fold predictions as new feature self.meta_model_.fit(out_of_fold_predictions, y) return self #Do the predictions of all base models on the test data and use the averaged predictions as #meta-features for the final prediction which is done by the meta-model def predict(self, X): meta_features = np.column_stack([ np.column_stack([model.predict(X) for model in base_models]).mean(axis=1) for base_models in self.base_models_ ]) return self.meta_model_.predict(meta_features) 12345stacked_averaged_models = StackingAveragedModels(base_models = (ENet, GBoost, KRR), meta_model = lasso)score = rmsle_cv(stacked_averaged_models)print(&quot;Stacking Averaged models score: {:.4f} ({:.4f})&quot;.format(score.mean(), score.std())) Stacking Averaged models score: 0.1079 (0.0054) 12345stacked_averaged_models_ridge = StackingAveragedModels(base_models = (ENet, GBoost, KRR), meta_model = ridge)score_ridge = rmsle_cv(stacked_averaged_models_ridge)print(&quot;Stacking Averaged models score: {:.4f} ({:.4f})&quot;.format(score_ridge.mean(), score_ridge.std())) Stacking Averaged models score: 0.1079 (0.0054) 12def rmsle(y, y_pred): return np.sqrt(mean_squared_error(y, y_pred)) 1234stacked_averaged_models.fit(train_df_munged.values, y_train)stacked_train_pred = stacked_averaged_models.predict(train_df_munged.values)stacked_pred = np.expm1(stacked_averaged_models.predict(test_df_munged.values))print(rmsle(y_train, stacked_train_pred)) 0.07384935969780994 1234stacked_averaged_models_ridge.fit(train_df_munged.values, y_train)stacked_train_pred_ridge = stacked_averaged_models_ridge.predict(train_df_munged.values)stacked_pred_ridge = np.expm1(stacked_averaged_models_ridge.predict(test_df_munged.values))print(rmsle(y_train, stacked_train_pred_ridge)) 0.07386785761731066 1234model_xgb.fit(train_df_munged, y_train)xgb_train_pred = model_xgb.predict(train_df_munged)xgb_pred = np.expm1(model_xgb.predict(test_df_munged))print(rmsle(y_train, xgb_train_pred)) 0.08404240349359858 1234model_lgb.fit(train_df_munged, y_train)lgb_train_pred = model_lgb.predict(train_df_munged)lgb_pred = np.expm1(model_lgb.predict(test_df_munged.values))print(rmsle(y_train, lgb_train_pred)) 0.06926259332568477 12345'''RMSE on the entire Train data when averaging'''print('RMSLE score on train data:')print(rmsle(y_train,stacked_train_pred*0.7 + xgb_train_pred*0.15 + lgb_train_pred*0.15)) #0.75 0.125 0.125 RMSLE score on train data: 0.07282898327817613 12345'''RMSE on the entire Train data when averaging'''print('RMSLE_ridge score on train data:')print(rmsle(y_train,stacked_train_pred_ridge*0.7 + xgb_train_pred*0.15 + lgb_train_pred*0.15)) RMSLE_ridge score on train data: 0.0728370672457598 1ensemble = stacked_pred*0.85 + xgb_pred*0.075 + lgb_pred*0.075 1ensemble_ridge = stacked_pred_ridge*0.75 + xgb_pred*0.125 + lgb_pred*0.125 12345sub = pd.DataFrame()test_ID = test_df['Id']sub['Id'] = test_IDsub['SalePrice'] = ensemble_ridgesub.to_csv('submission.csv',index=False)","link":"/projects/copy.html"}]}